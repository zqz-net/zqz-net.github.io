<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-NS3-simu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/07/29/NS3-simu/" class="article-date">
  <time class="dt-published" datetime="2020-07-29T06:13:49.255Z" itemprop="datePublished">2020-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/07/29/NS3-simu/">NS3-simu</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NS3-点对点仿真网络环境搭建"><a href="#NS3-点对点仿真网络环境搭建" class="headerlink" title="NS3 点对点仿真网络环境搭建"></a>NS3 点对点仿真网络环境搭建</h2><ol>
<li><code>创建NodeContianer</code>，点对点链路需要两个Node，每个Node，我们可以将其视为主机，我们需要在主机上添加NIC。</li>
<li><code>NetDevContainer</code>代表一张网卡，我们需要将其install到主机上，<code>NetDevContainer devices = point2point.install(nodes)</code>。</li>
<li>为主机安装协议栈<code>InternetStackHelper stack; stack.install(nodes)</code>。</li>
<li>为NIC分配IP地址，流程如下<code>Ipv4AddressHelper address; address.SetBase(&quot;10.0.1.0&quot;, &quot;255.255.255.0&quot;); Ipv4InterfaceContainer interfaces = address.Assgin(devices);</code>。</li>
<li>创建Application，生成流量去测试网络。</li>
<li>```cpp</li>
<li>/**</li>
<li>This program copy the ns3 tutorial first.cc</li>
<li>*/</li>
<li>#include “ns3/core-module.h”</li>
<li>#include “ns3/network-module.h”</li>
<li>#include “ns3/internet-module.h”</li>
<li>#include “ns3/point-to-point-module.h”</li>
<li>#include “ns3/applications-module.h”</li>
<li>using namespace ns3;</li>
<li>int main()</li>
<li>{<ol>
<li>//part of first.cc</li>
<li>NodeContainer nodes;</li>
<li>Nodes.Create(2);</li>
<li></li>
<li>PointToPointHelper point2point;</li>
<li>point2point.set(“DataRate”, StringValue(“5Mbps”));</li>
<li></li>
<li>NetDeviceContainer devices;</li>
<li>devices = point2point.Install(nodes);</li>
<li>//protocol stack</li>
<li>InternetStackHelper stack;</li>
<li>stack.Install(nodes);</li>
<li>//Set IP address</li>
<li>Ipv4AddressHelper address;</li>
<li>address.SetBase(“192.168.1.0”, “255.255.255.0”);</li>
<li>Ipv4InterfaceContainer interfaces = address.Assgin(devices);</li>
<li></li>
</ol>
</li>
<li>}</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/29/NS3-simu/" data-id="ckd6zyaur0000zox14sp38r5h" data-title="NS3-simu" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ovs packet process" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/30/ovs%20packet%20process/" class="article-date">
  <time class="dt-published" datetime="2020-06-30T08:25:11.486Z" itemprop="datePublished">2020-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/30/ovs%20packet%20process/">ovs packet process</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="skb-buff数据结构"><a href="#skb-buff数据结构" class="headerlink" title="skb_buff数据结构"></a>skb_buff数据结构</h2><h2 id="OVS的packet在datapath模块的处理流程"><a href="#OVS的packet在datapath模块的处理流程" class="headerlink" title="OVS的packet在datapath模块的处理流程"></a>OVS的packet在datapath模块的处理流程</h2><ol>
<li>驱动调用<code>netif_receive_skb(struct sk_buff *skb)</code>从网络中接收数据。</li>
<li>然后调用<code>netdev_port_receive() datapath/vport_netdev.c</code>函数</li>
<li><code>netdev_port_receive() datapath/vport_netdev.c</code>调用<code>ovs_vport_receive() datapath/vport.c</code></li>
<li><code>ovs_vport_receive()datapath/vport.c</code>调用<code>ovs_dp_process_packet() datapath/datapath.c</code></li>
<li>如果packet有流表匹配到，则<code>ovs_dp_process_packet() datapath/datapath.c</code>调用<code>ovs_execute_actions() datapath/action.c</code></li>
<li><code>ovs_execute_actions() datapath/action.c</code>调用<code>do_execute_actions() datapath/action.c</code>，该函数中的level如果等于一，则调用<code>process_deferred_actions() datapath/action.c</code>，<code>process_deferred_actions() datapath/action.c</code>中有一个action fifo，对于每一个在fifo的action都会调用<code>do_execute_actions()datapath/action.c</code>，如果action执行完毕之后，则会调用<code>ovs_dp_process_packet() datapath/datapath.c</code>进行下一个packet的处理。</li>
</ol>
<h2 id="Bridge-Queue-Configure"><a href="#Bridge-Queue-Configure" class="headerlink" title="Bridge Queue Configure"></a>Bridge Queue Configure</h2><ol>
<li><code>bridge_run() vswitchd/bridge.c</code> 调用<code>bridge_reconfigure() vswitchd/bridge.c</code></li>
<li><code>bridge_reconfigure() vswitchd/bridge.c</code>调用<code>iface_configure_qos() vswitchd/bridge.c</code></li>
<li><code>iface_configure_qos() vswitchd/bridge.c</code>会调用<code>netdev_set_queue() lib/netdev.c</code>，其中netdev_set_queue的实现如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">netdev_set_queue(struct netdev *netdev,</span><br><span class="line">                 unsigned int queue_id, const struct smap *details)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Now we analyze the structure of net_dev</span><br><span class="line">    const struct netdev_class *class &#x3D; netdev-&gt;netdev_class;</span><br><span class="line">    return (class-&gt;set_queue</span><br><span class="line">            ? class-&gt;set_queue(netdev, queue_id, details)</span><br><span class="line">            : EOPNOTSUPP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中<code>struct netdev lib/netdev-provider.h</code>数据结构如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct netdev &#123;</span><br><span class="line">    &#x2F;*This is only part of struct netdev*&#x2F;</span><br><span class="line">    char *name;                         </span><br><span class="line">    const struct netdev_class *netdev_class; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;the following is struct netdev_class</span><br><span class="line">struct netdev_class &#123;</span><br><span class="line">    &#x2F;* Type of netdevs in this class, e.g. &quot;system&quot;, &quot;tap&quot;, &quot;gre&quot;, etc.</span><br><span class="line">     *</span><br><span class="line">     * One of the providers should supply a &quot;system&quot; type, since this is</span><br><span class="line">     * the type assumed if no type is specified when opening a netdev.</span><br><span class="line">     * The &quot;system&quot; type corresponds to an existing network device on</span><br><span class="line">     * the system. *&#x2F;</span><br><span class="line">    const char *type;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if defined(__FreeBSD__) || defined(__NetBSD__)</span><br><span class="line">extern const struct netdev_class netdev_bsd_class;</span><br><span class="line">#elif defined(_WIN32)</span><br><span class="line">extern const struct netdev_class netdev_windows_class;</span><br><span class="line">#else</span><br><span class="line">extern const struct netdev_class netdev_linux_class;</span><br><span class="line">#endif</span><br><span class="line">extern const struct netdev_class netdev_internal_class;</span><br><span class="line">extern const struct netdev_class netdev_tap_class;</span><br></pre></td></tr></table></figure>
从上面的定义来看linux有三种devclass，分别是<code>netdev_linux_class, netdev_internal_class, netdev_tap_class</code>，netdev_class定义的所有接口如下，更为详尽的描述可见(detailed_netdev_class)[<a href="https://github.com/openvswitch/ovs/blob/master/lib/netdev-provider.h]。netdev提供商需要根据自己的需求去实现相应的接口。" target="_blank" rel="noopener">https://github.com/openvswitch/ovs/blob/master/lib/netdev-provider.h]。netdev提供商需要根据自己的需求去实现相应的接口。</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">struct netdev_class &#123;</span><br><span class="line"></span><br><span class="line">    const char *type;</span><br><span class="line"></span><br><span class="line">    bool is_pmd;</span><br><span class="line"></span><br><span class="line">    int (*init)(void);</span><br><span class="line"></span><br><span class="line">    void (*run)(const struct netdev_class *netdev_class);</span><br><span class="line"></span><br><span class="line">    void (*wait)(const struct netdev_class *netdev_class);</span><br><span class="line"></span><br><span class="line">    struct netdev *(*alloc)(void);</span><br><span class="line">    int (*construct)(struct netdev *);</span><br><span class="line">    void (*destruct)(struct netdev *);</span><br><span class="line">    void (*dealloc)(struct netdev *);</span><br><span class="line"></span><br><span class="line">    int (*get_config)(const struct netdev *netdev, struct smap *args);</span><br><span class="line"></span><br><span class="line">    int (*set_config)(struct netdev *netdev, const struct smap *args,</span><br><span class="line">                      char **errp);</span><br><span class="line"></span><br><span class="line">    const struct netdev_tunnel_config *</span><br><span class="line">        (*get_tunnel_config)(const struct netdev *netdev);</span><br><span class="line"></span><br><span class="line">    int (*build_header)(const struct netdev *, struct ovs_action_push_tnl *data,</span><br><span class="line">                        const struct netdev_tnl_build_header_params *params);</span><br><span class="line"></span><br><span class="line">    void (*push_header)(const struct netdev *,</span><br><span class="line">                        struct dp_packet *packet,</span><br><span class="line">                        const struct ovs_action_push_tnl *data);</span><br><span class="line"></span><br><span class="line">    struct dp_packet * (*pop_header)(struct dp_packet *packet);</span><br><span class="line"></span><br><span class="line">    int (*get_numa_id)(const struct netdev *netdev);</span><br><span class="line"></span><br><span class="line">    int (*set_tx_multiq)(struct netdev *netdev, unsigned int n_txq);</span><br><span class="line"></span><br><span class="line">    int (*send)(struct netdev *netdev, int qid, struct dp_packet_batch *batch,</span><br><span class="line">                bool concurrent_txq);</span><br><span class="line"></span><br><span class="line">    void (*send_wait)(struct netdev *netdev, int qid);</span><br><span class="line"></span><br><span class="line">    int (*set_etheraddr)(struct netdev *netdev, const struct eth_addr mac);</span><br><span class="line"></span><br><span class="line">    int (*get_etheraddr)(const struct netdev *netdev, struct eth_addr *mac);</span><br><span class="line"></span><br><span class="line">    int (*get_mtu)(const struct netdev *netdev, int *mtup);</span><br><span class="line"></span><br><span class="line">    int (*set_mtu)(struct netdev *netdev, int mtu);</span><br><span class="line"></span><br><span class="line">    int (*get_ifindex)(const struct netdev *netdev);</span><br><span class="line"></span><br><span class="line">    int (*get_carrier)(const struct netdev *netdev, bool *carrier);</span><br><span class="line"></span><br><span class="line">    long long int (*get_carrier_resets)(const struct netdev *netdev);</span><br><span class="line"></span><br><span class="line">    int (*set_miimon_interval)(struct netdev *netdev, long long int interval);</span><br><span class="line"></span><br><span class="line">    int (*get_stats)(const struct netdev *netdev, struct netdev_stats *);</span><br><span class="line"></span><br><span class="line">    int (*get_custom_stats)(const struct netdev *netdev,</span><br><span class="line">                            struct netdev_custom_stats *custom_stats);</span><br><span class="line"></span><br><span class="line">    int (*get_features)(const struct netdev *netdev,</span><br><span class="line">                        enum netdev_features *current,</span><br><span class="line">                        enum netdev_features *advertised,</span><br><span class="line">                        enum netdev_features *supported,</span><br><span class="line">                        enum netdev_features *peer);</span><br><span class="line"></span><br><span class="line">    int (*set_advertisements)(struct netdev *netdev,</span><br><span class="line">                              enum netdev_features advertise);</span><br><span class="line"></span><br><span class="line">    enum netdev_pt_mode (*get_pt_mode)(const struct netdev *netdev);</span><br><span class="line"></span><br><span class="line">    int (*set_policing)(struct netdev *netdev, unsigned int kbits_rate,</span><br><span class="line">                        unsigned int kbits_burst);</span><br><span class="line"></span><br><span class="line">    int (*get_qos_types)(const struct netdev *netdev, struct sset *types);</span><br><span class="line"></span><br><span class="line">    int (*get_qos_capabilities)(const struct netdev *netdev,</span><br><span class="line">                                const char *type,</span><br><span class="line">                                struct netdev_qos_capabilities *caps);</span><br><span class="line"></span><br><span class="line">    int (*get_qos)(const struct netdev *netdev,</span><br><span class="line">                   const char **typep, struct smap *details);</span><br><span class="line"></span><br><span class="line">    int (*set_qos)(struct netdev *netdev,</span><br><span class="line">                   const char *type, const struct smap *details);</span><br><span class="line"></span><br><span class="line">    int (*get_queue)(const struct netdev *netdev,</span><br><span class="line">                     unsigned int queue_id, struct smap *details);</span><br><span class="line"></span><br><span class="line">    int (*set_queue)(struct netdev *netdev,</span><br><span class="line">                     unsigned int queue_id, const struct smap *details);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    int (*delete_queue)(struct netdev *netdev, unsigned int queue_id);</span><br><span class="line"></span><br><span class="line">    int (*get_queue_stats)(const struct netdev *netdev, unsigned int queue_id,</span><br><span class="line">                           struct netdev_queue_stats *stats);</span><br><span class="line"></span><br><span class="line">    int (*queue_dump_start)(const struct netdev *netdev, void **statep);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    int (*queue_dump_next)(const struct netdev *netdev, void *state,</span><br><span class="line">                           unsigned int *queue_id, struct smap *details);</span><br><span class="line"></span><br><span class="line">    int (*queue_dump_done)(const struct netdev *netdev, void *state);</span><br><span class="line"></span><br><span class="line">    int (*dump_queue_stats)(const struct netdev *netdev,</span><br><span class="line">                            void (*cb)(unsigned int queue_id,</span><br><span class="line">                                       struct netdev_queue_stats *,</span><br><span class="line">                                       void *aux),</span><br><span class="line">                            void *aux);</span><br><span class="line"></span><br><span class="line">    int (*set_in4)(struct netdev *netdev, struct in_addr addr,</span><br><span class="line">                   struct in_addr mask);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int (*get_addr_list)(const struct netdev *netdev, struct in6_addr **in,</span><br><span class="line">                         struct in6_addr **mask, int *n_in6);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    int (*add_router)(struct netdev *netdev, struct in_addr router);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int (*get_next_hop)(const struct in_addr *host, struct in_addr *next_hop,</span><br><span class="line">                        char **netdev_name);</span><br><span class="line"></span><br><span class="line">    int (*get_status)(const struct netdev *netdev, struct smap *smap);</span><br><span class="line"></span><br><span class="line">    int (*arp_lookup)(const struct netdev *netdev, ovs_be32 ip,</span><br><span class="line">                      struct eth_addr *mac);</span><br><span class="line"></span><br><span class="line">    int (*update_flags)(struct netdev *netdev, enum netdev_flags off,</span><br><span class="line">                        enum netdev_flags on, enum netdev_flags *old_flags);</span><br><span class="line"></span><br><span class="line">    struct netdev_rxq *(*rxq_alloc)(void);</span><br><span class="line">    int (*rxq_construct)(struct netdev_rxq *);</span><br><span class="line">    void (*rxq_destruct)(struct netdev_rxq *);</span><br><span class="line"> </span><br><span class="line">    bool (*rxq_enabled)(struct netdev_rxq *);</span><br><span class="line"></span><br><span class="line">    int (*rxq_recv)(struct netdev_rxq *rx, struct dp_packet_batch *batch,</span><br><span class="line">                    int *qfill);</span><br><span class="line">    void (*rxq_wait)(struct netdev_rxq *rx);</span><br><span class="line"></span><br><span class="line">    int (*rxq_drain)(struct netdev_rxq *rx);</span><br><span class="line"></span><br><span class="line">    uint32_t (*get_block_id)(struct netdev *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/30/ovs%20packet%20process/" data-id="ckc1ooim40000acx17zhvcs2h" data-title="ovs packet process" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-multihost_container" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/28/multihost_container/" class="article-date">
  <time class="dt-published" datetime="2020-06-28T13:56:34.129Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/28/multihost_container/">multihost_container</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="OpenvSwitch-with-GRE-tunnel"><a href="#OpenvSwitch-with-GRE-tunnel" class="headerlink" title="OpenvSwitch with GRE tunnel"></a>OpenvSwitch with GRE tunnel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># configure ovs</span><br><span class="line">ovs-vsctl add-br br0</span><br><span class="line">ip link add veth0 type peer name veth1</span><br><span class="line">ovs-vsctl add-port br0 veth1</span><br><span class="line">brctl addif docker５0 veth0</span><br><span class="line">ip link set veth1 up</span><br><span class="line">ip link set veth0 up</span><br><span class="line">ovs-vsctl add-port br0 gre0 -- set interface gre0 type&#x3D;gre options:remote_ip&#x3D;192.168.1.150</span><br></pre></td></tr></table></figure>
<p>##　容器的连接，允许所有容器间互联</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/multihost_container/" data-id="ckbz506n80000mkx14of65cug" data-title="multihost_container" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ovs" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/28/ovs/" class="article-date">
  <time class="dt-published" datetime="2020-06-28T03:25:22.846Z" itemprop="datePublished">2020-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/28/ovs/">ovs</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="OVS-conponent"><a href="#OVS-conponent" class="headerlink" title="OVS conponent"></a>OVS conponent</h1><h2 id="Common-Data-Structure"><a href="#Common-Data-Structure" class="headerlink" title="Common Data Structure"></a>Common Data Structure</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">struct hmap_node &#123;</span><br><span class="line">	size_t hash;</span><br><span class="line">	struct hmap_node *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct hmap &#123;</span><br><span class="line">	struct hmap_node **buckets;</span><br><span class="line">	struct hmap_node *one;</span><br><span class="line">	size_t mask;</span><br><span class="line">	size_t n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct sset &#123;</span><br><span class="line">	struct hmap map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ovs_list &#123;</span><br><span class="line">	struct ovs_list *prev;</span><br><span class="line">	struct ovs_list *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct OVS_LOCKABLE ovs_mutex &#123;</span><br><span class="line">	pthread_mutex_t lock;</span><br><span class="line">	const chr* where;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct guarded_list &#123;</span><br><span class="line">	struct ovs_mutex mutex;</span><br><span class="line">	struct ovs_list list;</span><br><span class="line">	size_t n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ofproto_dpif &#123;</span><br><span class="line">    &#x2F;* In &#39;all_ofproto_dpifs_by_name&#39;. *&#x2F;</span><br><span class="line">    struct hmap_node all_ofproto_dpifs_by_name_node;</span><br><span class="line"></span><br><span class="line">    &#x2F;* In &#39;all_ofproto_dpifs_by_uuid&#39;. *&#x2F;</span><br><span class="line">    struct hmap_node all_ofproto_dpifs_by_uuid_node;</span><br><span class="line"></span><br><span class="line">    struct ofproto up;</span><br><span class="line">    struct dpif_backer *backer;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Unique identifier for this instantiation of this bridge in this running</span><br><span class="line">     * process.  *&#x2F;</span><br><span class="line">    struct uuid uuid;</span><br><span class="line"></span><br><span class="line">    ATOMIC(ovs_version_t) tables_version;  &#x2F;* For classifier lookups. *&#x2F;</span><br><span class="line"></span><br><span class="line">    uint64_t dump_seq; &#x2F;* Last read of udpif_dump_seq(). *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Special OpenFlow rules. *&#x2F;</span><br><span class="line">    struct rule_dpif *miss_rule; &#x2F;* Sends flow table misses to controller. *&#x2F;</span><br><span class="line">    struct rule_dpif *no_packet_in_rule; &#x2F;* Drops flow table misses. *&#x2F;</span><br><span class="line">    struct rule_dpif *drop_frags_rule; &#x2F;* Used in OFPUTIL_FRAG_DROP mode. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Bridging. *&#x2F;</span><br><span class="line">    struct netflow *netflow;</span><br><span class="line">    struct dpif_sflow *sflow;</span><br><span class="line">    struct dpif_ipfix *ipfix;</span><br><span class="line">    struct hmap bundles;        &#x2F;* Contains &quot;struct ofbundle&quot;s. *&#x2F;</span><br><span class="line">    struct mac_learning *ml;</span><br><span class="line">    struct mcast_snooping *ms;</span><br><span class="line">    bool has_bonded_bundles;</span><br><span class="line">    bool lacp_enabled;</span><br><span class="line">    struct mbridge *mbridge;</span><br><span class="line"></span><br><span class="line">    struct ovs_mutex stats_mutex;</span><br><span class="line">    struct netdev_stats stats OVS_GUARDED; &#x2F;* To account packets generated and</span><br><span class="line">                                            * consumed in userspace. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Spanning tree. *&#x2F;</span><br><span class="line">    struct stp *stp;</span><br><span class="line">    long long int stp_last_tick;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Rapid Spanning Tree. *&#x2F;</span><br><span class="line">    struct rstp *rstp;</span><br><span class="line">    long long int rstp_last_tick;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ports. *&#x2F;</span><br><span class="line">    struct sset ports;             &#x2F;* Set of standard port names. *&#x2F;</span><br><span class="line">    struct sset ghost_ports;       &#x2F;* Ports with no datapath port. *&#x2F;</span><br><span class="line">    struct sset port_poll_set;     &#x2F;* Queued names for port_poll() reply. *&#x2F;</span><br><span class="line">    int port_poll_errno;           &#x2F;* Last errno for port_poll() reply. *&#x2F;</span><br><span class="line">    uint64_t change_seq;           &#x2F;* Connectivity status changes. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Work queues. *&#x2F;</span><br><span class="line">    struct guarded_list ams;      &#x2F;* Contains &quot;struct ofproto_async_msgs&quot;s. *&#x2F;</span><br><span class="line">    struct seq *ams_seq;          &#x2F;* For notifying &#39;ams&#39; reception. *&#x2F;</span><br><span class="line">    uint64_t ams_seqno;</span><br><span class="line"></span><br><span class="line">    bool is_controller_connected; &#x2F;* True if any controller admitted this</span><br><span class="line">                                   * switch connection. *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;in vswitchd struct bridge</span><br><span class="line">struct bridge &#123;</span><br><span class="line">    struct hmap_node node;      &#x2F;* In &#39;all_bridges&#39;. *&#x2F;</span><br><span class="line">    char *name;                 &#x2F;* User-specified arbitrary name. *&#x2F;</span><br><span class="line">    char *type;                 &#x2F;* Datapath type. *&#x2F;</span><br><span class="line">    struct eth_addr ea;         &#x2F;* Bridge Ethernet Address. *&#x2F;</span><br><span class="line">    struct eth_addr default_ea; &#x2F;* Default MAC. *&#x2F;</span><br><span class="line">    const struct ovsrec_bridge *cfg;</span><br><span class="line"></span><br><span class="line">    &#x2F;* OpenFlow switch processing. *&#x2F;</span><br><span class="line">    struct ofproto *ofproto;    &#x2F;* OpenFlow switch. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Bridge ports. *&#x2F;</span><br><span class="line">    struct hmap ports;          &#x2F;* &quot;struct port&quot;s indexed by name. *&#x2F;</span><br><span class="line">    struct hmap ifaces;         &#x2F;* &quot;struct iface&quot;s indexed by ofp_port. *&#x2F;</span><br><span class="line">    struct hmap iface_by_name;  &#x2F;* &quot;struct iface&quot;s indexed by name. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Port mirroring. *&#x2F;</span><br><span class="line">    struct hmap mirrors;        &#x2F;* &quot;struct mirror&quot; indexed by UUID. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Auto Attach *&#x2F;</span><br><span class="line">    struct hmap mappings;       &#x2F;* &quot;struct&quot; indexed by UUID *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Used during reconfiguration. *&#x2F;</span><br><span class="line">    struct shash wanted_ports;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Synthetic local port if necessary. *&#x2F;</span><br><span class="line">    struct ovsrec_port synth_local_port;</span><br><span class="line">    struct ovsrec_interface synth_local_iface;</span><br><span class="line">    struct ovsrec_interface *synth_local_ifacep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;bridge_run() call ofproto_run()</span><br></pre></td></tr></table></figure>
<h2 id="OVS支持的QOS-TYPE"><a href="#OVS支持的QOS-TYPE" class="headerlink" title="OVS支持的QOS TYPE"></a>OVS支持的QOS TYPE</h2><ol>
<li>HTB: Hierarchy token bucket</li>
<li>HFSC: Hierachy fair service curve</li>
<li>CODEL: Controlled delay</li>
<li>FQCODEL: Fair Queue controlled delay</li>
<li>NETEM: Network emulator</li>
<li>SFQ: Stochastic fair queueing </li>
</ol>
<h2 id="datapath"><a href="#datapath" class="headerlink" title="datapath"></a>datapath</h2><p>Datapth是OVS转发平面的组成部分，它被实现为linux kernel中的一个模块，</p>
<h2 id="Kernel-Datapath"><a href="#Kernel-Datapath" class="headerlink" title="Kernel Datapath"></a>Kernel Datapath</h2><p>在<code>lib\dpif-netlink.c</code>中实现</p>
<h2 id="Userspace-Datapath"><a href="#Userspace-Datapath" class="headerlink" title="Userspace Datapath"></a>Userspace Datapath</h2><p>在<code>lib/dpif-netdev.c</code>中实现</p>
<h2 id="Netdev"><a href="#Netdev" class="headerlink" title="Netdev"></a>Netdev</h2><p><code>struct netdev</code>代表了在OVS用户空间中的一个网络设备，它用来控制在内核端的设备（可能是NIC，TAP）。<br><img src="/2020/06/28/ovs/netdev.PNG" alt="arch"></p>
<h2 id="OVS中的Queue"><a href="#OVS中的Queue" class="headerlink" title="OVS中的Queue"></a>OVS中的Queue</h2><p><code>struct ofproto ofproto/ofproto-provider.h</code> <code>struct ofproto_class ofproto/ofproto-provider.h</code>的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct ofproto &#123;</span><br><span class="line">    struct hmap_node hmap_node; &#x2F;* In global &#39;all_ofprotos&#39; hmap. *&#x2F;</span><br><span class="line">    const struct ofproto_class *ofproto_class;</span><br><span class="line">    char *type;                 &#x2F;* Datapath type. *&#x2F;</span><br><span class="line">    char *name;                 &#x2F;* Datapath name. *&#x2F;</span><br><span class="line">	&#x2F;*part of definition*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*这个函数定义了一系列的函数指针接口，我只选取了与queue有关的接口*&#x2F;</span><br><span class="line">struct ofproto_class &#123;</span><br><span class="line">	&#x2F;* Registers meta-data associated with the &#39;n_qdscp&#39; Qualities of Service</span><br><span class="line">     * &#39;queues&#39; attached to &#39;ofport&#39;.  This data is not intended to be</span><br><span class="line">     * sufficient to implement QoS.  Instead, providers may use this</span><br><span class="line">     * information to implement features which require knowledge of what queues</span><br><span class="line">     * exist on a port, and some basic information about them.</span><br><span class="line">     *</span><br><span class="line">     * EOPNOTSUPP as a return value indicates that this ofproto_class does not</span><br><span class="line">     * support QoS, as does a null pointer. *&#x2F;</span><br><span class="line">    int (*set_queues)(struct ofport *ofport,</span><br><span class="line">                      const struct ofproto_port_queue *queues, size_t n_qdscp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>在 ofproto.h lib/ofproto.h</code>出现了<code>ofproto_port_queue</code>和<code>int ofproto_port_set_queues()</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct ofproto_port_queue &#123;</span><br><span class="line">    uint32_t queue;             &#x2F;* Queue ID. *&#x2F;</span><br><span class="line">    uint8_t dscp;               &#x2F;* DSCP bits (e.g. [0, 63]). *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int ofproto_port_set_queues(struct ofproto *, ofp_port_t ofp_port,</span><br><span class="line">                            const struct ofproto_port_queue *,</span><br><span class="line">                            size_t n_queues);</span><br><span class="line"></span><br><span class="line">&#x2F;*implementation of ofproto_port_set_queues*&#x2F;</span><br><span class="line">int</span><br><span class="line">ofproto_port_set_queues(struct ofproto *ofproto, ofp_port_t ofp_port,</span><br><span class="line">                        const struct ofproto_port_queue *queues,</span><br><span class="line">                        size_t n_queues)</span><br><span class="line">&#123;</span><br><span class="line">    struct ofport *ofport &#x3D; ofproto_get_port(ofproto, ofp_port);</span><br><span class="line"></span><br><span class="line">    if (!ofport) &#123;</span><br><span class="line">        VLOG_WARN(&quot;%s: cannot set queues on nonexistent port %&quot;PRIu32,</span><br><span class="line">                  ofproto-&gt;name, ofp_port);</span><br><span class="line">        return ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (ofproto-&gt;ofproto_class-&gt;set_queues</span><br><span class="line">            ? ofproto-&gt;ofproto_class-&gt;set_queues(ofport, queues, n_queues)</span><br><span class="line">            : EOPNOTSUPP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="OVS-源码剖析"><a href="#OVS-源码剖析" class="headerlink" title="OVS 源码剖析"></a>OVS 源码剖析</h1><h2 id="OVS中的关键数据结构"><a href="#OVS中的关键数据结构" class="headerlink" title="OVS中的关键数据结构"></a>OVS中的关键数据结构</h2><ol>
<li>vport.h<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct vport &#123;</span><br><span class="line">	struct net_device *dev; &#x2F;&#x2F;指向网络设备</span><br><span class="line">	struct datapath	*dp;    &#x2F;&#x2F;指明该端口属于哪个datapath</span><br><span class="line">	struct vport_portids __rcu *upcall_portids;</span><br><span class="line">	u16 port_no; &#x2F;&#x2F;指示该端口位于dp的port数组的哪个index</span><br><span class="line"></span><br><span class="line">	struct hlist_node hash_node;</span><br><span class="line">	struct hlist_node dp_hash_node;</span><br><span class="line">	const struct vport_ops *ops;</span><br><span class="line"></span><br><span class="line">	struct list_head detach_list;</span><br><span class="line">	struct rcu_head rcu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct vport_parms &#123;</span><br><span class="line">    &#x2F;&#x2F;这些参数用于创建一个新的vport</span><br><span class="line">	const char *name; &#x2F;&#x2F;vport的名字</span><br><span class="line">	enum ovs_vport_type type; &#x2F;&#x2F;vport的类型</span><br><span class="line">	struct nlattr *options; </span><br><span class="line"></span><br><span class="line">	&#x2F;* For ovs_vport_alloc(). *&#x2F;</span><br><span class="line">	struct datapath *dp; &#x2F;&#x2F;vport属于哪个dp</span><br><span class="line">	u16 port_no; &#x2F;&#x2F;vport的端口号</span><br><span class="line">	struct nlattr *upcall_portids;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>datapath.h<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct datapath &#123;</span><br><span class="line">	struct rcu_head rcu;</span><br><span class="line">	struct list_head list_node;</span><br><span class="line">	struct flow_table table; &#x2F;&#x2F;流表</span><br><span class="line">	struct hlist_head *ports; &#x2F;&#x2F;端口</span><br><span class="line"></span><br><span class="line">	&#x2F;* Stats. *&#x2F;</span><br><span class="line">	struct dp_stats_percpu __percpu *stats_percpu;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Network namespace ref. *&#x2F;</span><br><span class="line">	possible_net_t net;</span><br><span class="line">	u32 user_features;</span><br><span class="line">	u32 max_headroom;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Switch meters. *&#x2F;</span><br><span class="line">	struct hlist_head *meters;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="OpenvSwitch-接受包的流程分析"><a href="#OpenvSwitch-接受包的流程分析" class="headerlink" title="OpenvSwitch 接受包的流程分析"></a>OpenvSwitch 接受包的流程分析</h2>要让ovs接受网卡上的数据，首先要将网卡绑定到OpenvSwitch的port上，命令如下<code>ovs-vsctl add-port br0 eth0</code>，绑定之后，每当有数据包过来时，OVS都会调用数据包的接受函数<code>int ovs_vport_receive(struct vport *, struct sk_buff *, const struct ip_tunnel_info *)</code>函数位于<code>datapath/vport.c</code>中。代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int ovs_vport_receive(struct vport *vport, struct sk_buff *skb,</span><br><span class="line">		      const struct ip_tunnel_info *tun_info)</span><br><span class="line">&#123;</span><br><span class="line">	struct sw_flow_key key;</span><br><span class="line">	int error;</span><br><span class="line"></span><br><span class="line">	OVS_CB(skb)-&gt;input_vport &#x3D; vport;</span><br><span class="line">	OVS_CB(skb)-&gt;mru &#x3D; 0;</span><br><span class="line">	OVS_CB(skb)-&gt;cutlen &#x3D; 0;</span><br><span class="line">	if (unlikely(dev_net(skb-&gt;dev) !&#x3D; ovs_dp_get_net(vport-&gt;dp))) &#123;</span><br><span class="line">		u32 mark;</span><br><span class="line"></span><br><span class="line">		mark &#x3D; skb-&gt;mark;</span><br><span class="line">		skb_scrub_packet(skb, true);</span><br><span class="line">		skb-&gt;mark &#x3D; mark;</span><br><span class="line">		tun_info &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ovs_skb_init_inner_protocol(skb);</span><br><span class="line">	skb_clear_ovs_gso_cb(skb);</span><br><span class="line">	&#x2F;* Extract flow from &#39;skb&#39; into &#39;key&#39;. *&#x2F;</span><br><span class="line">	error &#x3D; ovs_flow_key_extract(tun_info, skb, &amp;key);</span><br><span class="line">	if (unlikely(error)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		return error;</span><br><span class="line">	&#125;</span><br><span class="line">	ovs_dp_process_packet(skb, &amp;key);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
数据包进入openvswitch之后，会调用函数<code>void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)</code>，对数据包进行处理，这个函数会对数据包进行流表的匹配，然后执行相应的action，action会对数据包的一些数据域进行修改，然后再将数据包发送出去，这时候会调用vport.c的数据包发送函数<code>void ovs_vport_send(struct vport *vport, struct sk_buff *skb, u8 mac_proto)</code>，此时会把数据包发送到端口绑定的网络设备中，此时网卡驱动会将数据包的数据发送出去。</li>
</ol>
<p>ovs_dp_process_packet的源代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	const struct vport *p &#x3D; OVS_CB(skb)-&gt;input_vport;</span><br><span class="line">	struct datapath *dp &#x3D; p-&gt;dp;</span><br><span class="line">	struct sw_flow *flow;</span><br><span class="line">	struct sw_flow_actions *sf_acts;</span><br><span class="line">	struct dp_stats_percpu *stats;</span><br><span class="line">	u64 *stats_counter;</span><br><span class="line">	u32 n_mask_hit;</span><br><span class="line"></span><br><span class="line">	stats &#x3D; this_cpu_ptr(dp-&gt;stats_percpu);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;查找flow</span><br><span class="line">	flow &#x3D; ovs_flow_tbl_lookup_stats(&amp;dp-&gt;table, key, skb_get_hash(skb),</span><br><span class="line">					 &amp;n_mask_hit);</span><br><span class="line">	if (unlikely(!flow)) &#123;</span><br><span class="line">		struct dp_upcall_info upcall;</span><br><span class="line">		int error;</span><br><span class="line"></span><br><span class="line">		memset(&amp;upcall, 0, sizeof(upcall));</span><br><span class="line">		upcall.cmd &#x3D; OVS_PACKET_CMD_MISS;</span><br><span class="line">		upcall.portid &#x3D; ovs_vport_find_upcall_portid(p, skb);</span><br><span class="line">		upcall.mru &#x3D; OVS_CB(skb)-&gt;mru;</span><br><span class="line">		error &#x3D; ovs_dp_upcall(dp, skb, key, &amp;upcall, 0);</span><br><span class="line">		if (unlikely(error))</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">		else</span><br><span class="line">			consume_skb(skb);</span><br><span class="line">		stats_counter &#x3D; &amp;stats-&gt;n_missed;</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ovs_flow_stats_update(flow, key-&gt;tp.flags, skb);</span><br><span class="line">	sf_acts &#x3D; rcu_dereference(flow-&gt;sf_acts);</span><br><span class="line">    &#x2F;&#x2F;执行action</span><br><span class="line">	ovs_execute_actions(dp, skb, sf_acts, key);</span><br><span class="line"></span><br><span class="line">	stats_counter &#x3D; &amp;stats-&gt;n_hit;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	&#x2F;* Update datapath statistics. *&#x2F;</span><br><span class="line">	u64_stats_update_begin(&amp;stats-&gt;syncp);</span><br><span class="line">	(*stats_counter)++;</span><br><span class="line">	stats-&gt;n_mask_hit +&#x3D; n_mask_hit;</span><br><span class="line">	u64_stats_update_end(&amp;stats-&gt;syncp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是ovs_vport_send的<font color="red">源代码</font>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void ovs_vport_send(struct vport *vport, struct sk_buff *skb, u8 mac_proto)</span><br><span class="line">&#123;</span><br><span class="line">	int mtu &#x3D; vport-&gt;dev-&gt;mtu;</span><br><span class="line"></span><br><span class="line">	switch (vport-&gt;dev-&gt;type) &#123;</span><br><span class="line">	case ARPHRD_NONE:</span><br><span class="line">		if (mac_proto &#x3D;&#x3D; MAC_PROTO_ETHERNET) &#123;</span><br><span class="line">			skb_reset_network_header(skb);</span><br><span class="line">			skb_reset_mac_len(skb);</span><br><span class="line">			skb-&gt;protocol &#x3D; htons(ETH_P_TEB);</span><br><span class="line">		&#125; else if (mac_proto !&#x3D; MAC_PROTO_NONE) &#123;</span><br><span class="line">			WARN_ON_ONCE(1);</span><br><span class="line">			goto drop;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	case ARPHRD_ETHER:</span><br><span class="line">		if (mac_proto !&#x3D; MAC_PROTO_ETHERNET)</span><br><span class="line">			goto drop;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		goto drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (unlikely(packet_length(skb, vport-&gt;dev) &gt; mtu &amp;&amp;</span><br><span class="line">		     !skb_is_gso(skb))) &#123;</span><br><span class="line">		net_warn_ratelimited(&quot;%s: dropped over-mtu packet: %d &gt; %d\n&quot;,</span><br><span class="line">				     vport-&gt;dev-&gt;name,</span><br><span class="line">				     packet_length(skb, vport-&gt;dev), mtu);</span><br><span class="line">		vport-&gt;dev-&gt;stats.tx_errors++;</span><br><span class="line">		goto drop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	skb-&gt;dev &#x3D; vport-&gt;dev;</span><br><span class="line">	vport-&gt;ops-&gt;send(skb);</span><br><span class="line">	return;</span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OVS的流表查询调用"><a href="#OVS的流表查询调用" class="headerlink" title="OVS的流表查询调用"></a>OVS的流表查询调用</h2><p>如之前看到的，当packet进入ovs_dp_process_packet之后，ovs会调用<code>struct sw_flow *ovs_flow_tbl_lookup_stats</code>（位于datapath/flow_table.c）进行流表的查询，该函数的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">struct sw_flow *ovs_flow_tbl_lookup_stats(struct flow_table *tbl,</span><br><span class="line">					  const struct sw_flow_key *key,</span><br><span class="line">					  u32 skb_hash,</span><br><span class="line">					  u32 *n_mask_hit)</span><br><span class="line">&#123;</span><br><span class="line">	struct mask_array *ma &#x3D; rcu_dereference(tbl-&gt;mask_array);</span><br><span class="line">	struct table_instance *ti &#x3D; rcu_dereference(tbl-&gt;ti);</span><br><span class="line">	struct mask_cache_entry *entries, *ce;</span><br><span class="line">	struct sw_flow *flow;</span><br><span class="line">	u32 hash;</span><br><span class="line">	int seg;</span><br><span class="line"></span><br><span class="line">	*n_mask_hit &#x3D; 0;</span><br><span class="line">	if (unlikely(!skb_hash)) &#123;</span><br><span class="line">		u32 mask_index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		return flow_lookup(tbl, ti, ma, key, n_mask_hit, &amp;mask_index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Pre and post recirulation flows usually have the same skb_hash</span><br><span class="line">	 * value. To avoid hash collisions, rehash the &#39;skb_hash&#39; with</span><br><span class="line">	 * &#39;recirc_id&#39;.  *&#x2F;</span><br><span class="line">	if (key-&gt;recirc_id)</span><br><span class="line">		skb_hash &#x3D; jhash_1word(skb_hash, key-&gt;recirc_id);</span><br><span class="line"></span><br><span class="line">	ce &#x3D; NULL;</span><br><span class="line">	hash &#x3D; skb_hash;</span><br><span class="line">	entries &#x3D; this_cpu_ptr(tbl-&gt;mask_cache);</span><br><span class="line"></span><br><span class="line">	&#x2F;* Find the cache entry &#39;ce&#39; to operate on. *&#x2F;</span><br><span class="line">	for (seg &#x3D; 0; seg &lt; MC_HASH_SEGS; seg++) &#123;</span><br><span class="line">		int index &#x3D; hash &amp; (MC_HASH_ENTRIES - 1);</span><br><span class="line">		struct mask_cache_entry *e;</span><br><span class="line"></span><br><span class="line">		e &#x3D; &amp;entries[index];</span><br><span class="line">		if (e-&gt;skb_hash &#x3D;&#x3D; skb_hash) &#123;</span><br><span class="line">			flow &#x3D; flow_lookup(tbl, ti, ma, key, n_mask_hit,</span><br><span class="line">					   &amp;e-&gt;mask_index);</span><br><span class="line">			if (!flow)</span><br><span class="line">				e-&gt;skb_hash &#x3D; 0;</span><br><span class="line">			return flow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ce || e-&gt;skb_hash &lt; ce-&gt;skb_hash)</span><br><span class="line">			ce &#x3D; e;  &#x2F;* A better replacement cache candidate. *&#x2F;</span><br><span class="line"></span><br><span class="line">		hash &gt;&gt;&#x3D; MC_HASH_SHIFT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Cache miss, do full lookup. *&#x2F;</span><br><span class="line">	flow &#x3D; flow_lookup(tbl, ti, ma, key, n_mask_hit, &amp;ce-&gt;mask_index);</span><br><span class="line">	if (flow)</span><br><span class="line">		ce-&gt;skb_hash &#x3D; skb_hash;</span><br><span class="line"></span><br><span class="line">	return flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中会调用flow_lookup（位于datapath/flow_table.c）进行查找，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static struct sw_flow *flow_lookup(struct flow_table *tbl,</span><br><span class="line">				   struct table_instance *ti,</span><br><span class="line">				   const struct mask_array *ma,</span><br><span class="line">				   const struct sw_flow_key *key,</span><br><span class="line">				   u32 *n_mask_hit,</span><br><span class="line">				   u32 *index)</span><br><span class="line">&#123;</span><br><span class="line">	struct sw_flow_mask *mask;</span><br><span class="line">	struct sw_flow *flow;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (*index &lt; ma-&gt;max) &#123;</span><br><span class="line">		mask &#x3D; rcu_dereference_ovsl(ma-&gt;masks[*index]);</span><br><span class="line">		if (mask) &#123;</span><br><span class="line">			flow &#x3D; masked_flow_lookup(ti, key, mask, n_mask_hit);</span><br><span class="line">			if (flow)</span><br><span class="line">				return flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; ma-&gt;max; i++)  &#123;</span><br><span class="line"></span><br><span class="line">		if (i &#x3D;&#x3D; *index)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		mask &#x3D; rcu_dereference_ovsl(ma-&gt;masks[i]);</span><br><span class="line">		if (!mask)</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		flow &#x3D; masked_flow_lookup(ti, key, mask, n_mask_hit);</span><br><span class="line">		if (flow) &#123; &#x2F;* Found *&#x2F;</span><br><span class="line">			*index &#x3D; i;</span><br><span class="line">			return flow;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在flow_lookup中有会调用masked_flow_lookup（位于datapath/flow_table.c），该函数的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static struct sw_flow *masked_flow_lookup(struct table_instance *ti,</span><br><span class="line">					  const struct sw_flow_key *unmasked,</span><br><span class="line">					  const struct sw_flow_mask *mask,</span><br><span class="line">					  u32 *n_mask_hit)</span><br><span class="line">&#123;</span><br><span class="line">	struct sw_flow *flow;</span><br><span class="line">	struct hlist_head *head;</span><br><span class="line">	u32 hash;</span><br><span class="line">	struct sw_flow_key masked_key;</span><br><span class="line"></span><br><span class="line">	ovs_flow_mask_key(&amp;masked_key, unmasked, false, mask);</span><br><span class="line">	hash &#x3D; flow_hash(&amp;masked_key, &amp;mask-&gt;range);</span><br><span class="line">	head &#x3D; find_bucket(ti, hash);</span><br><span class="line">	(*n_mask_hit)++;</span><br><span class="line">	hlist_for_each_entry_rcu(flow, head, flow_table.node[ti-&gt;node_ver]) &#123;</span><br><span class="line">		if (flow-&gt;mask &#x3D;&#x3D; mask &amp;&amp; flow-&gt;flow_table.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">		    flow_cmp_masked_key(flow, &amp;masked_key, &amp;mask-&gt;range))</span><br><span class="line">			return flow;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，与查询有关的函数调用则全部清晰明了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/28/ovs/" data-id="ckbymsov90000u4x1gr8ydjs4" data-title="ovs" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/20/C++%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2020-06-20T04:01:41.562Z" itemprop="datePublished">2020-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/20/C++%E9%9D%A2%E8%AF%95%E9%A2%98/">C++面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="C-Fundamental"><a href="#C-Fundamental" class="headerlink" title="C++　Fundamental"></a>C++　Fundamental</h4><h5 id="vector内存管理"><a href="#vector内存管理" class="headerlink" title="vector内存管理"></a>vector内存管理</h5><h5 id="map底层实现"><a href="#map底层实现" class="headerlink" title="map底层实现"></a>map底层实现</h5><h5 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h5><ol>
<li>管道</li>
<li>FIFO</li>
<li>信号量</li>
<li>本地套接字</li>
</ol>
<h5 id="AVL树，B树，RB-Tree"><a href="#AVL树，B树，RB-Tree" class="headerlink" title="AVL树，B树，RB-Tree"></a>AVL树，B树，RB-Tree</h5><h5 id="new和malloc区别"><a href="#new和malloc区别" class="headerlink" title="new和malloc区别"></a>new和malloc区别</h5><h5 id="C-多态机制"><a href="#C-多态机制" class="headerlink" title="C++多态机制"></a>C++多态机制</h5><ol>
<li>运行时多态</li>
<li>编译时多态</li>
</ol>
<h5 id="C-虚函数底层实现"><a href="#C-虚函数底层实现" class="headerlink" title="C++虚函数底层实现"></a>C++虚函数底层实现</h5><h4 id="Algorithm-Part"><a href="#Algorithm-Part" class="headerlink" title="Algorithm Part"></a>Algorithm Part</h4><ol>
<li>在坐标轴上，从一个点到另一个点有多少种走法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/20/C++%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckbq43c4z0000vkx18b0yfral" data-title="C++面试题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-container-network" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/15/container-network/" class="article-date">
  <time class="dt-published" datetime="2020-06-15T09:36:51.007Z" itemprop="datePublished">2020-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/15/container-network/">Container Network</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="The-Container-Networking-Model-CNM"><a href="#The-Container-Networking-Model-CNM" class="headerlink" title="The Container Networking Model(CNM)"></a>The Container Networking Model(CNM)</h2><p>Container network model: <img src="/2020/06/15/container-network/cnm.PNG" alt="CNM"></p>
<h2 id="CNM-Constrcuts"><a href="#CNM-Constrcuts" class="headerlink" title="CNM Constrcuts"></a>CNM Constrcuts</h2><ol>
<li><strong>Sandbox</strong>: a sandbox contains configuration of a container’s network stack. This includes the management of container’s interfaces, routing table, and DNS settings.</li>
<li><strong>Endpoint</strong>: a endpoint joins a sandbox to a network.</li>
<li><strong>Network</strong>: an implementation of anNetwork could be linux bridge, a VLAN, etc. A network is a collection of endpoints that have connectivity between them.</li>
</ol>
<h2 id="CNM-Driver-Interfaces"><a href="#CNM-Driver-Interfaces" class="headerlink" title="CNM Driver Interfaces"></a>CNM Driver Interfaces</h2><p>CNM Drivers <img src="/2020/06/15/container-network/drivers.PNG" alt="CNM Drivers"><br>The container networking model provides two pluggable and open interfaces can be used by users and community. They <strong>Network Drivers</strong> and <strong>IPAM Drivers</strong>.</p>
<ol>
<li>Network Drivers: Docker Network Drivers provide the actual implementation that makes networks work. There are two broad type of CNM network drivers:<ul>
<li>Native Network Drivers: Native Network Drivers are a native part of the Docker Engine and are provided by Docker.</li>
<li>Remote Network Drivers: is created by community and other vendors. These drivers can be used to provide integration with incumbent software and hardware.</li>
</ul>
</li>
<li>IPAM Drivers: Docker has native IP Address Management(IPAM) Drivers that <em>provides default subnets</em> or IP addresses for the networks and endpoints if they are not specified.</li>
</ol>
<h2 id="Docker-Native-Network-Drivers"><a href="#Docker-Native-Network-Drivers" class="headerlink" title="Docker Native Network Drivers"></a>Docker Native Network Drivers</h2><p>The follow drivers are invoked by standard <code>docker network</code> commands. </p>
<ol>
<li>Host: container will use the network stack of host. There is no namespace speration, all interfaces on host can be used directly by containers. The container behaves like process on the host. We should prevent port conflicts</li>
<li>Bridge: create linux bridge on host, containers on bridge can communicate with each other. External access to containers can also be configured through <code>bridge</code> driver.</li>
<li>Overlay: create overlay network supports multi-host networks. It use a combination of <code>local Linux Bridges</code> and <code>VXLAN</code>.</li>
<li>MACVLAN:</li>
</ol>
<h2 id="Linux-Network-Fundmentals"><a href="#Linux-Network-Fundmentals" class="headerlink" title="Linux Network Fundmentals"></a>Linux Network Fundmentals</h2><ol>
<li>The Linux Bridge: is a Layer 2 device and forwardd traffic based on MAC addresses which it learns  dynamically by inspecting traffic.</li>
<li>Network Namespace: is an isolated network stack in the kernek with its own interfaces, routes, and firewall rules. Namespces ensure two containers on same host aren’t able to communicate with each other. CNM network drivers implement separate namespaces for each containers.</li>
<li>Virtual Ethernet Devices: <strong>veth</strong> is Linux networking interface that acts as a connecting wire between two network namespaces.</li>
<li>iptables: is a native packet filtering system. The native Docker network drivers utilize iptables extensively to segment network traffic, provide host port mapping, and to mark traffic for load balancing decisions.</li>
</ol>
<h2 id="Container-Overlay-Network"><a href="#Container-Overlay-Network" class="headerlink" title="Container Overlay Network"></a>Container Overlay Network</h2><p>A key component in providing portability for distributed containerized applications</p>
<h2 id="Docker-跨主机连接"><a href="#Docker-跨主机连接" class="headerlink" title="Docker 跨主机连接"></a>Docker 跨主机连接</h2><ol>
<li>bridge<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.修改 &#x2F;etc&#x2F;network&#x2F;interfaces文件</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 10.211.55.3</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.211.55.1</span><br><span class="line">bridge_ports eth0</span><br><span class="line">2. &#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">DOCKER_OPTS&#x3D;&quot;-b br0 --fixed-cidr&#x3D;&quot;10.211.55.128&#x2F;26&quot;</span><br></pre></td></tr></table></figure></li>
<li>openvswitch</li>
<li>weave</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/15/container-network/" data-id="ckbq43c540001vkx1b90pdr74" data-title="Container Network" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/06/13/hello-world/" class="article-date">
  <time class="dt-published" datetime="2020-06-13T15:12:32.489Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/06/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/hello-world/" data-id="ckbq43c5m0005vkx1ctksagfc" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/NS3-simu/">NS3-simu</a>
          </li>
        
          <li>
            <a href="/2020/06/30/ovs%20packet%20process/">ovs packet process</a>
          </li>
        
          <li>
            <a href="/2020/06/28/multihost_container/">multihost_container</a>
          </li>
        
          <li>
            <a href="/2020/06/28/ovs/">ovs</a>
          </li>
        
          <li>
            <a href="/2020/06/20/C++%E9%9D%A2%E8%AF%95%E9%A2%98/">C++面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>